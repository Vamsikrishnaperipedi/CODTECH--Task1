/*The memory controller*/



module 
memory_controller (
    input wire clk,
    input wire reset_n,
    input wire [31:0] write_data,       // Data to be written
    input wire [15:0] address,           // Memory address
    input wire write_enable,              // Write enable signal
    input wire read_enable,               // Read enable signal
    output reg [31:0] read_data,         // Data read from memory
    output reg ready,                     // Ready signal to indicate operation completion
    // DDR SDRAM interface signals
    output reg ddr_clk,
    output reg ddr_cs_n,
    output reg ddr_ras_n,
    output reg ddr_cas_n,
    output reg ddr_we_n,
    output reg [15:0] ddr_addr,
    inout wire [31:0] ddr_dq
);

// State definitions
typedef enum reg [1:0] {
    IDLE,
    WRITE,
    READ
} state_t;

state_t current_state, next_state;

// Internal signals
reg [31:0] ddr_data_out;
reg write_done, read_done;

// State transition logic
always @(posedge clk or negedge reset_n) begin
    if (!reset_n) begin
        current_state <= IDLE;
        ready <= 1'b1;
        // Initialize DDR signals
        ddr_cs_n <= 1'b1;
        ddr_ras_n <= 1'b1;
        ddr_cas_n <= 1'b1;
        ddr_we_n <= 1'b1;
    end else begin
        current_state <= next_state;
    end
end

// Next state logic and output logic
always @* begin
    // Default outputs
    next_state = current_state;
    read_data = 32'b0;
    ready = 1'b0;
    write_done = 1'b0;
    read_done = 1'b0;

    case (current_state)
        IDLE: begin
            if (write_enable) begin
                next_state = WRITE;
                ddr_data_out = write_data;
                ready = 1'b0;
            end else if (read_enable) begin
                next_state = READ;
                ready = 1'b0;
            end
        end
